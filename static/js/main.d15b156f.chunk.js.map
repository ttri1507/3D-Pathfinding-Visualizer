{"version":3,"sources":["components/floor_texture.jpg","components/algorithms/helpers.js","components/algorithms/weightedSearchAlgorithm.js","components/algorithms/mazeAlgorithms.js","components/Grid.js","components/algorithms/unweightedSearchAlgorithm.js","components/Floor.js","components/Controls.js","components/World.js","App.js","reportWebVitals.js","index.js"],"names":["tweenToColor","node","geometry","colors","a","duration","options","i","length","TWEEN","Tween","faces","color","to","onUpdate","colorsNeedUpdate","delay","start","position","facesIndices","forEach","indices","vertices","y","verticesNeedUpdate","weightedSearchAlgorithm","grid","target","nodesToAnimate","name","heuristic","distance","direction","totalDistance","unvisitedNodes","nodes","row","push","getAllNodes","currentNode","closestNode","status","Infinity","id","updateNeighbors","currentClosest","index","heuristicDistance","splice","neighbors","col","filter","neighbor","stutus","getNeighbors","updateNode","targetNode","actualStartNode","actualTargetNode","distanceToCompare","nodeOne","nodeTwo","x1","y1","x2","y2","getDistance","weight","manhattanDistance","Math","pow","previousNode","path","nodeOneCoordinates","nodeTwoCoordinates","abs","recursiveDivisionMaze","rowStart","rowEnd","colStart","colEnd","orientation","surroundingWalls","type","reservedStatus","j","converNodeToType","possibleRows","number","possibleCols","randomRowIndex","floor","random","randomColIndex","currentRow","colRandom","currentCol","rowRandom","includes","Grid","props","groundMaterial","previousHoverNodeId","currentHoverNodeId","mouseDownX","mouseDownY","mouseIsUp","useState","THREE","groundGeometry","selectedAlgorithm","selectedMazeAlgorithm","runState","worldProperties","clearTheWalls","clearWalls","clearThePath","clearPath","algorithmSpeed","useEffect","console","log","processedSuccessfuly","startNode","terrain","finishNode","finish","algorithm","structure","exploredNodes","shift","pop","unshift","unweightedSearchAlgorithm","nodesInShortestPathOrder","getNodesInShortestPathOrder","visitedNodesInOrder","timerDelay","setTimeout","undefined","updateRunState","animateShortestPath","r","g","b","visited","animateAlgorithm","visualizeAlgorithm","randomMaze","animateMaze","loader","useMemo","load","img","texture","wrapS","wrapT","repeat","x","map","side","vertexColors","receiveShadow","mesh","useRef","tempGrid","createNode","renderLoop","initializeGrid","faceIndex","cols","window","requestAnimationFrame","nodeRow","rows","nodeCol","default","wall","hoverLoop","update","mouseUpHandler","event","clientX","clientY","nodeId","linearIndex","findNodeId","stopClearWalls","removeAll","stopClearPath","stopMazeSelection","ref","args","gridDimensions","rotation","PI","onPointerDown","e","onPointerUp","resetStatus","onPointerMove","attach","object","Floor","Controls","camera","useThree","controls","z","easing","Easing","Exponential","Out","onComplete","current","enableRotate","World","width","innerWidth","height","innerHeigh","setSelectedAlgorithm","setRunState","resetCamera","setResetCamera","setClearWalls","setClearPath","cameraPosition","setSelectedMazeAlgorithm","setAlgorithmSpeed","selected_algo_is_undefined","setAlgo","classes","makeStyles","theme","root","margin","spacing","background","border","borderRadius","useStyles","align","className","Select","displayEmpty","onChange","value","MenuItem","Button","onClick","variant","disabled","startIcon","colorManagement","fov","aspect","far","intensity","groundColor","castShadow","newState","nodeDimensions","updateResetStatus","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d15b156f.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/floor_texture.9dabdb90.jpg\";","import TWEEN from \"@tweenjs/tween.js\";\n\nexport function getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (const row of grid) {\n\t\tnodes.push(...row);\n\t}\n\treturn nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\t//Excluding finish node\n\tif(currentNode.previousNode !== null) {\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\twhile (currentNode !== null) {\n\t\t// Excluding start node\n\t\tif(currentNode.previousNode === null) {\n\t\t\tbreak;\n\t\t}\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\n\treturn nodesInShortestPathOrder;\n}\n\nexport async function tweenToColor(node, geometry, colors, duration = 300, options) {\n\tfor(let i=0; i<colors.length; i++) {\n\t\tnew TWEEN.Tween(node.faces[1].color)\n\t\t\t.to(colors[i], duration)\n\t\t\t.onUpdate(() => {\n\t\t\t\tgeometry.colorsNeedUpdate = true;\n\t\t\t})\n\t\t\t.delay(i*200)\n\t\t\t.start();\n\t\tnew TWEEN.Tween(node.faces[2].color)\n\t\t\t.to(colors[i], duration)\n\t\t\t.onUpdate(() => {\n\t\t\t\tgeometry.colorsNeedUpdate = true;\n\t\t\t})\n\t\t\t.delay(i*200)\n\t\t\t.start();\n\t}\n\tif (options) {\n\t\tif (options.position) {\n\t\t\tvar facesIndices = [\"a\", \"b\", \"c\"];\n\t\t\tfacesIndices.forEach(function (indices) {\n\t\t\t\tnew TWEEN.Tween(geometry.vertices[node.faces[1][indices]])\n\t\t\t\t\t.to({ y: 0.5 }, duration)\n\t\t\t\t\t.onUpdate(() => {\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\t})\n\t\t\t\t\t.start();\n\t\t\t\tnew TWEEN.Tween(geometry.vertices[node.faces[2][indices]])\n\t\t\t\t\t.to({ y: 0.5 }, duration)\n\t\t\t\t\t.onUpdate(() => {\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\t})\n\t\t\t\t\t.start();\n\t\t\t});\n\t\t\tfacesIndices.forEach(function (indices) {\n\t\t\t\tnew TWEEN.Tween(geometry.vertices[node.faces[1][indices]])\n\t\t\t\t\t.to({ y: 0 }, duration)\n\t\t\t\t\t.onUpdate(() => {\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\t})\n\t\t\t\t\t.delay(100)\n\t\t\t\t\t.start();\n\t\t\t\tnew TWEEN.Tween(geometry.vertices[node.faces[2][indices]])\n\t\t\t\t\t.to({ y: 0 }, duration)\n\t\t\t\t\t.onUpdate(() => {\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\t})\n\t\t\t\t\t.delay(100)\n\t\t\t\t\t.start();\n\t\t\t});\n\t\t}\n\t}\n}","import { getAllNodes } from './helpers.js';\n\nexport function weightedSearchAlgorithm(grid, start, target, nodesToAnimate, name, heuristic) {\n  // Initialze nodes\n\tstart.distance = 0;\n\tstart.direction = \"right\";\n\tif(name === \"aStar\") {\n\t\tstart.totalDistance = 0;\n\t}\n\t// Should be a Priority Queue\n  let unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length) {\n        let currentNode = closestNode(unvisitedNodes, name);\n    while (currentNode.status === \"wall\" && unvisitedNodes.length) {\n        currentNode = closestNode(unvisitedNodes, name)\n    }\n    if (currentNode.distance === Infinity) return false;\n    nodesToAnimate.push(currentNode);\n    //if(currentNode.status !== \"start\" && currentNode.status !== \"finish\"){\n      currentNode.status = \"visited\";\n    //}\n    // Ending condition\n\t\tif (currentNode.id === target.id) return \"success!\";\n\t\t// Updating neighbors\n    if (name === \"CLA\" || name === \"greedy\" || name === \"aStar\") {\n      updateNeighbors(grid, currentNode, start, target, name, heuristic);\n    } else if (name === \"Dijkstra\") {\n      updateNeighbors(grid, currentNode);\n    }\n  }\n}\n\nfunction closestNode(unvisitedNodes, name) {\n  let currentClosest, index;\n  for (let i = 0; i < unvisitedNodes.length; i++) {\n\t\tif(name === \"aStar\") {\n\t\t\tif (!currentClosest || currentClosest.totalDistance > unvisitedNodes[i].totalDistance) {\n\t\t\t\tcurrentClosest = unvisitedNodes[i];\n\t\t\t\tindex = i;\n\t\t\t} else if (currentClosest.totalDistance === unvisitedNodes[i].totalDistance) {\n\t\t\t\tif (currentClosest.heuristicDistance > unvisitedNodes[i].heuristicDistance) {\n\t\t\t\t\tcurrentClosest = unvisitedNodes[i];\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!currentClosest || currentClosest.distance > unvisitedNodes[i].distance) {\n\t\t\t\tcurrentClosest = unvisitedNodes[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n  }\n  unvisitedNodes.splice(index, 1);\n  return currentClosest;\n}\n\nfunction updateNeighbors(grid, node, start, target, name, heuristic) {\n  let neighbors = getNeighbors(node, grid);\n  for (let neighbor of neighbors) {\n    if (target) {\n      updateNode(node, neighbor, start, target, name, heuristic);\n    } else {\n      updateNode(node, neighbor);\n    }\n  }\n}\n\n\n\nfunction updateNode(currentNode, targetNode, actualStartNode, actualTargetNode, name, heuristic) {\n  let distance = getDistance(currentNode, targetNode);\n  let distanceToCompare;\n  if (actualTargetNode && name === \"CLA\") {\n    let weight = targetNode.weight === 15 ? 15 : 1;\n    if (heuristic === \"manhattanDistance\") {\n      distanceToCompare = currentNode.distance + (distance[0] + weight) * manhattanDistance(targetNode, actualTargetNode);\n    } else if (heuristic === \"poweredManhattanDistance\") {\n      distanceToCompare = currentNode.distance + targetNode.weight + distance[0] + Math.pow(manhattanDistance(targetNode, actualTargetNode), 2);\n    } else if (heuristic === \"extraPoweredManhattanDistance\") {\n      distanceToCompare = currentNode.distance + (distance[0] + weight) * Math.pow(manhattanDistance(targetNode, actualTargetNode), 7);\n    }\n  } else if (actualTargetNode && name === \"greedy\") {\n    distanceToCompare = targetNode.weight + distance[0] + manhattanDistance(targetNode, actualTargetNode);\n  } else if(name === \"aStar\") {\n\t\tif (!targetNode.heuristicDistance) targetNode.heuristicDistance = manhattanDistance(targetNode, actualTargetNode);\n\t\tdistanceToCompare = currentNode.distance + targetNode.weight + distance[0];\n\t} else {\n    distanceToCompare = currentNode.distance + targetNode.weight + distance[0];\n  }\n  if (distanceToCompare < targetNode.distance) {\n    targetNode.distance = distanceToCompare;\n    targetNode.previousNode = currentNode;\n    targetNode.path = distance[1];\n\t\ttargetNode.direction = distance[2];\n\t\tif(name === \"aStar\") {\n\t\t\ttargetNode.totalDistance = targetNode.distance + targetNode.heuristicDistance;\n\t\t}\n  }\n}\n\nfunction getNeighbors(node, grid) {\n\tconst neighbors = [];\n\tconst {col, row} = node;\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\treturn neighbors.filter(neighbor => neighbor.stutus !== \"visited\");\n}\n\n\nfunction getDistance(nodeOne, nodeTwo) {\n  let x1 = nodeOne.row;\n  let y1 = nodeOne.col;\n  let x2 = nodeTwo.row;\n  let y2 = nodeTwo.col;\n\tif (x2 < x1 && y1 === y2) {\n    if (nodeOne.direction === \"up\") {\n      return [1, [\"f\"], \"up\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [2, [\"l\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [2, [\"r\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [3, [\"r\", \"r\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [1.5, null, \"up\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [2.5, null, \"up\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [1.5, null, \"up\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [2.5, null, \"up\"];\n    }\n  } else if (x2 > x1 && y1 === y2) {\n    if (nodeOne.direction === \"up\") {\n      return [3, [\"r\", \"r\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [2, [\"r\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [2, [\"l\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [1, [\"f\"], \"down\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [2.5, null, \"down\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [1.5, null, \"down\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [2.5, null, \"down\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [1.5, null, \"down\"];\n    }\n  }\n  if (y2 < y1 && x1 === x2) {\n    if (nodeOne.direction === \"up\") {\n      return [2, [\"l\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [3, [\"l\", \"l\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [1, [\"f\"], \"left\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [2, [\"r\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [2.5, null, \"left\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [2.5, null, \"left\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [1.5, null, \"left\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [1.5, null, \"left\"];\n    }\n  } else if (y2 > y1 && x1 === x2) {\n    if (nodeOne.direction === \"up\") {\n      return [2, [\"r\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [1, [\"f\"], \"right\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [3, [\"r\", \"r\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [2, [\"l\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [1.5, null, \"right\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [1.5, null, \"right\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [2.5, null, \"right\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [2.5, null, \"right\"];\n    }\n  } \n}\n\nfunction manhattanDistance(nodeOne, nodeTwo) {\n  let nodeOneCoordinates = [nodeOne.row, nodeOne.col];\n  let nodeTwoCoordinates = [nodeTwo.row, nodeTwo.col]\n  let xChange = Math.abs(nodeOneCoordinates[0] - nodeTwoCoordinates[0]);\n  let yChange = Math.abs(nodeOneCoordinates[1] - nodeTwoCoordinates[1]);\n  return (xChange + yChange);\n}","export function randomMaze(grid, nodesToAnimate, type) {\n\tfor(let i=0; i<grid.length; i++) {\n\t\tfor(let j=0; j<grid[0].length; j++) {\n\t\t\tlet random = Math.random();\n\t\t\tlet currentNode = grid[i][j];\n\t\t\tlet reservedStatus = [\"start\", \"finish\"];\n\t\t\tlet randomTwo = type === \"wall\" ? 0.25 : 0.35;\n\t\t\tif (random < randomTwo && !reservedStatus.includes(currentNode.status)) {\n\t\t\t\tnodesToAnimate.push(currentNode);\n\t\t\t\tif (type === \"wall\") {\n\t\t\t\t\t// currentNode.status = \"wall\";\n\t\t\t\t\tcurrentNode.weight = 0;\n\t\t\t\t} else if (type === \"weight\") {\n\t\t\t\t\t// currentNode.status = \"default\";  // should be \"weight\"; left for later implementation\n\t\t\t\t\tcurrentNode.weight = 15;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, colEnd, orientation, surroundingWalls, nodesToAnimate, type) {\n  if (rowEnd < rowStart || colEnd < colStart) {\n    return;\n\t}\n\n\tlet reservedStatus = [\"start\", \"finish\"];\n\tfunction converNodeToType(node) {\n\t\tif(reservedStatus.includes(node.status)) return;\n\t\tnodesToAnimate.push(node);\n\t\tif (type === \"wall\") {\n\t\t\t// node.status = \"wall\";\n\t\t\tnode.weight = 0;\n\t\t} else if (type === \"weight\") {\n\t\t\t// node.status = \"default\";  // should be \"weight\"; left for later implementation\n\t\t\tnode.weight = 15;\n\t\t}\n\t}\n\n  if (!surroundingWalls) {\n\t\tlet i, j;\n\t\t//First row\n\t\tfor(j=0; j<grid[0].length; j++) {\n\t\t\ti = 0;\n\t\t\tconverNodeToType(grid[i][j]);\n\t\t}\n\t\t//Last row\n\t\tfor(j=0; j<grid[0].length; j++) {\n\t\t\ti = grid.length-1;\n\t\t\tconverNodeToType(grid[i][j]);\n\t\t}\n\t\t//First column\n\t\tfor(i=1; i<grid.length-1; i++) {\n\t\t\tj = 0;\n\t\t\tconverNodeToType(grid[i][j]);\n\t\t}\n\t\t//Last column\n\t\tfor(i=1; i<grid.length-1; i++) {\n\t\t\tj = grid[0].length-1;\n\t\t\tconverNodeToType(grid[i][j]);\n\t\t}\n    surroundingWalls = true;\n  }\n  if (orientation === \"horizontal\") {\n    let possibleRows = [];\n    for (let number = rowStart; number <= rowEnd; number += 2) {\n      possibleRows.push(number);\n    }\n    let possibleCols = [];\n    for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\n      possibleCols.push(number);\n    }\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n    let currentRow = possibleRows[randomRowIndex];\n\t\tlet colRandom = possibleCols[randomColIndex];\n\t\t\n\t\tlet i = currentRow, j;\n\t\tfor(j=colStart-1; j<=colEnd+1; j++) {\n\t\t\tif(j !== colRandom) {\n\t\t\t\tconverNodeToType(grid[i][j]);\n\t\t\t}\n\t\t}\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      recursiveDivisionMaze(grid, rowStart, currentRow - 2, colStart, colEnd, orientation, surroundingWalls, nodesToAnimate, type);\n    } else {\n      recursiveDivisionMaze(grid, rowStart, currentRow - 2, colStart, colEnd, \"vertical\", surroundingWalls, nodesToAnimate, type);\n    }\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      recursiveDivisionMaze(grid, currentRow + 2, rowEnd, colStart, colEnd, orientation, surroundingWalls, nodesToAnimate, type);\n    } else {\n      recursiveDivisionMaze(grid, currentRow + 2, rowEnd, colStart, colEnd, \"vertical\", surroundingWalls, nodesToAnimate, type);\n    }\n  } else {\n    let possibleCols = [];\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n    let possibleRows = [];\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n    let currentCol = possibleCols[randomColIndex];\n\t\tlet rowRandom = possibleRows[randomRowIndex];\n\n\t\tlet i, j = currentCol;\n\t\tfor(i=rowStart-1; i<=rowEnd+1; i++) {\n\t\t\tif(i !== rowRandom) {\n\t\t\t\tconverNodeToType(grid[i][j]);\n\t\t\t}\n\t\t}\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, currentCol - 2, \"horizontal\", surroundingWalls, nodesToAnimate, type);\n    } else {\n      recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, currentCol - 2, orientation, surroundingWalls, nodesToAnimate, type);\n    }\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      recursiveDivisionMaze(grid, rowStart, rowEnd, currentCol + 2, colEnd, \"horizontal\", surroundingWalls, nodesToAnimate, type);\n    } else {\n      recursiveDivisionMaze(grid, rowStart, rowEnd, currentCol + 2, colEnd, orientation, surroundingWalls, nodesToAnimate, type);\n    }\n\t}\n};","import React, { useState, useRef, useEffect, useMemo } from 'react'\nimport * as THREE from 'three'\nimport img from './floor_texture.jpg';\nimport { tweenToColor, getNodesInShortestPathOrder } from './algorithms/helpers'\nimport TWEEN from '@tweenjs/tween.js';\nimport { weightedSearchAlgorithm } from \"./algorithms/weightedSearchAlgorithm.js\";\nimport { unweightedSearchAlgorithm } from \"./algorithms/unweightedSearchAlgorithm.js\";\nimport { randomMaze, recursiveDivisionMaze } from './algorithms/mazeAlgorithms';\n\n\n\nfunction Grid(props) {\n\n  let groundMaterial;\n  let groundMesh;\n  let mouseDownX = 0;\n  let mouseDownY = 0;\n  let previousHoverNodeId;\n  let currentHoverNodeId;\n\n  let mouseIsUp = true;\n\n  //const [mouseIsUp, setMouseIsUp] = useState(true);\n  \n  const [groundGeometry, setGroundGeometry] = useState(new THREE.PlaneGeometry(300,300,30,30));\n  //const [runState, setRunState] = useState(props.worldProperties.runState);\n  const selectedAlgorithm = props.selectedAlgorithm;\n  const selectedMazeAlgorithm = props.selectedMazeAlgorithm;\n  const runState = props.worldProperties.runState;\n  const clearTheWalls = props.worldProperties.clearWalls; //rename this variable\n  const clearThePath = props.worldProperties.clearPath; // rename this variable too\n  const algorithmSpeed = props.algorithmSpeed;\n\n\n\n\n  useEffect(() => {\n    if(props.worldProperties.runState === true){\n      visualizeAlgorithm();\n    }\n    else if(props.worldProperties.clearWalls === true){\n      clearWalls();\n    }\n    else if(props.worldProperties.clearPath === true){\n      clearPath();\n    }\n    else if(props.selectedMazeAlgorithm === \"randomMaze\"){\n      clearPath();\n      let nodesToAnimate = [];\n      randomMaze(terrain.grid, nodesToAnimate, \"wall\");\n      animateMaze(nodesToAnimate, \"wall\", 30);\n    }\n    else if(props.selectedMazeAlgorithm === \"recursiveDivision\"){\n      clearPath();\n      let nodesToAnimate = [];\n      recursiveDivisionMaze(\n        terrain.grid, \n        2, \n        terrain.grid.length - 3,\n         2, \n         terrain.grid.length - 3, \n         \"horizontal\",\n         false,\n         nodesToAnimate,\n         \"wall\");\n\n         animateMaze(nodesToAnimate, \"wall\", 30)\n    }\n    //const algorithmSpeed = props.algorithmSpeed;\n    //console.log(algorithmSpeed);\n  }, [runState, clearTheWalls, clearThePath, selectedMazeAlgorithm]);\n\n\n  const loader = useMemo(() => new THREE.TextureLoader().load(img,\n    function(texture){\n        texture.wrapS = THREE.RepeatWrapping;\n        texture.wrapT = THREE.RepeatWrapping;\n        texture.repeat.x = 30;\n        texture.repeat.y = 30;\n        groundMaterial = new THREE.MeshLambertMaterial({\n          map: texture,\n          side: THREE.FrontSide,\n          vertexColors: THREE.FaceColors,\n        });\n        groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);\n\t\t\t\tgroundMesh.receiveShadow = true;\n    }), [img]);\n\n    \n    \n    groundMaterial = new THREE.MeshLambertMaterial({\n      map: loader,\n      side: THREE.FrontSide,\n      vertexColors: THREE.FaceColors,\n    });\n\n    const mesh = useRef(null);\n    const [terrain, setTerrain] = useState({\n      grid: initializeGrid(),\n    });\n  \n  function initializeGrid(){\n    let tempGrid = [];\n    for(let i = 0; i < 30; i++){\n        let currentRow = [];\n        for(let j = 0; j < 30; j++){\n            let node = createNode(i, j);\n            currentRow.push(node);\n        }\n        tempGrid.push(currentRow);\n    }\n    renderLoop();\n   return tempGrid;\n  }   \n\n  function createNode(row, col){\n\n    let status = \"default\";\n    let faces = {};\n    let faceIndex = row * 2 * props.worldProperties.cols + col * 2 ;\n    faces[1] = groundGeometry.faces[faceIndex];\n    faceIndex = faceIndex % 2 === 0 ? faceIndex + 1 : faceIndex - 1;\n    faces[2] = groundGeometry.faces[faceIndex];\n\n    if(row === props.worldProperties.start.row && col === props.worldProperties.start.col){\n      status = \"start\";\n    }\n    else if(row === props.worldProperties.finish.row && col === props.worldProperties.finish.col){\n      status = \"finish\";\n    }\n    let node = {\n        id: row * props.worldProperties.cols + col,\n        row: row,\n        col: col,\n        faces: faces,\n        status: status,\n        distance: Infinity,\n        totalDistance: Infinity,\n        heuristicDistance: null,\n        direction: null,\n        weight: 0,\n        previousNode: null,\n    };\n    if(status === \"start\"){\n      tweenToColor(node, groundGeometry, [props.worldProperties.colors.start]);\n      \n    }\n    else if(status === \"finish\"){\n      tweenToColor(node, groundGeometry, [props.worldProperties.colors.finish]);\n    }\n    return node;\n  }\n\n  function renderLoop(){\n    window.requestAnimationFrame(renderLoop);\n    //if(props.resetStatus){\n      hoverLoop();\n   // }\n    TWEEN.update();\n  }\n\n  function hoverLoop(){\n    if(mouseIsUp || currentHoverNodeId === previousHoverNodeId){\n      return;\n    }\n    else{\n      previousHoverNodeId = currentHoverNodeId;\n      let nodeRow = Math.floor(currentHoverNodeId / props.worldProperties.rows);\n      let nodeCol = currentHoverNodeId % props.worldProperties.cols\n      if((nodeRow === props.worldProperties.start.row && nodeCol === props.worldProperties.start.col) \n        || (nodeRow === props.worldProperties.finish.row && nodeCol === props.worldProperties.finish.col)){\n        return;\n      }\n      else if(terrain.grid[nodeRow][nodeCol].status === \"wall\"){\n        terrain.grid[nodeRow][nodeCol].status = \"default\";\n        tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.default]);\n      }\n      else\n      {\n        terrain.grid[nodeRow][nodeCol].status = \"wall\";\n        tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\n      }\n    \n    }\n    //get coordinates of node i just clicked on\n    \n  }\n\n  function mouseUpHandler(event){\n    if((mouseDownX !== event.clientX) || (mouseDownY !== event.clientY)){\n      return;\n    }\n    else\n    {\n      let nodeId = findNodeId(event.faceIndex);\n      if((nodeId.nodeRow === props.worldProperties.start.row && nodeId.nodeCol === props.worldProperties.start.col) \n        || (nodeId.nodeRow === props.worldProperties.finish.row && nodeId.nodeCol === props.worldProperties.finish.col)){\n      return;\n      }\n      else if(terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status === \"wall\"){\n        terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status = \"default\";\n        tweenToColor(terrain.grid[nodeId.nodeRow][nodeId.nodeCol], groundGeometry, [props.worldProperties.colors.default]);\n        console.log(terrain.grid[nodeId.nodeRow][nodeId.nodeCol]);\n      }\n      else\n      {\n        terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status = \"wall\";\n        tweenToColor(terrain.grid[nodeId.nodeRow][nodeId.nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\n        console.log(terrain.grid[nodeId.nodeRow][nodeId.nodeCol]);\n      }\n    }\n\n  }\n    \n  \n  function findNodeId(faceIndex){\n    let linearIndex = Math.floor(faceIndex / 2);\n    return {\n      nodeRow: Math.floor(linearIndex / props.worldProperties.rows),\n      nodeCol: linearIndex % props.worldProperties.cols,\n    }\n  }\n  function mouseDownHandler(event){\n      mouseDownX = event.clientX;     //set X and Y mouse coordinates when mouseDown\n      mouseDownY = event.clientY;\n  }\n  \n  function visualizeAlgorithm(){\n    console.log(\"Dijkstra Dijkstra Dijkstra\");\n    clearPath();\n    let nodesToAnimate = [];\n    let processedSuccessfuly;\n    const startNode = terrain.grid[props.worldProperties.start.row][props.worldProperties.start.col];\n    const finishNode = terrain.grid[props.worldProperties.finish.row][props.worldProperties.finish.col];\n    if(selectedAlgorithm.type === \"weighted\"){\n      processedSuccessfuly = weightedSearchAlgorithm(\n        terrain.grid,\n        startNode,\n        finishNode,\n        nodesToAnimate,\n        selectedAlgorithm.algorithm,\n        selectedAlgorithm.heuristic,\n      );\n      console.log(processedSuccessfuly);\n    }\n    else{\n      processedSuccessfuly = unweightedSearchAlgorithm(\n        terrain.grid,\n        startNode,\n        finishNode,\n        nodesToAnimate,\n        selectedAlgorithm.algorithm,\n      );\n    }\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    //add conditions for unweighted and no paths found\n    //console.log(algorithmSpeed + \" is the speed were using\")\n    animateAlgorithm(nodesToAnimate, nodesInShortestPathOrder, algorithmSpeed);\n    \n    \n  }\n  function animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder, timerDelay){\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n\t\t\t\tif (i === visitedNodesInOrder.length) {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tanimateShortestPath(nodesInShortestPathOrder, 5 * timerDelay);\n\t\t\t\t\t}, timerDelay * i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ((visitedNodesInOrder[i].row === props.worldProperties.start.row &&\n            visitedNodesInOrder[i].col === props.worldProperties.start.col) ||\n\t\t\t\t\t(visitedNodesInOrder[i].row === props.worldProperties.finish.row &&\n\t\t\t\t\t\tvisitedNodesInOrder[i].col === props.worldProperties.finish.col)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconst node = visitedNodesInOrder[i];\n\t\t\t\t\tif (!node) return;\n\t\t\t\t\ttweenToColor(\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tgroundGeometry,\n\t\t\t\t\t\t[{ r: 1.0, g: 0.321, b: 0.784 }, props.worldProperties.colors.visited],\n\t\t\t\t\t\t300,\n\t\t\t\t\t\t{ position: false }\n\t\t\t\t\t);\n\t\t\t\t}, timerDelay * i);\n      }\n      \n  }\n  function animateShortestPath(nodesInShortestPathOrder, timerDelay){\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        tweenToColor(node, groundGeometry, [props.worldProperties.colors.path], undefined, {\n          position: false,\n        });\n        if (i === nodesInShortestPathOrder.length - 1) {\n                }\n      }, timerDelay * i);\n    }\n    props.updateRunState(false);\n    console.log(terrain.grid[5][5]);\n  }\n\n  function clearWalls(){\n    for(let i = 0; i < props.worldProperties.rows; i++){\n      for(let j = 0; j < props.worldProperties.cols; j++){\n        if(terrain.grid[i][j].status === \"wall\"){\n          terrain.grid[i][j].status = \"default\";\n          tweenToColor(terrain.grid[i][j], groundGeometry, [props.worldProperties.colors.default])\n        }\n      }\n    }\n    props.stopClearWalls();\n  }\n  function clearPath(){\n    TWEEN.removeAll();\n    for(let i = 0; i < props.worldProperties.rows; i++){\n      for(let j = 0; j < props.worldProperties.cols; j++){\n        if(i === props.worldProperties.start.row && j === props.worldProperties.start.col){\n          terrain.grid[i][j].status = \"start\"; \n        }\n        if(i === props.worldProperties.finish.row && j === props.worldProperties.finish.col){\n          terrain.grid[i][j].status = \"finish\"; \n        }\n        \n        if(terrain.grid[i][j].status === \"visited\"){\n          terrain.grid[i][j].status = \"default\";\n          tweenToColor(terrain.grid[i][j], groundGeometry, [props.worldProperties.colors.default]);\n        }\n        terrain.grid[i][j].distance = Infinity;\n        terrain.grid[i][j].totalDistance = Infinity;\n        terrain.grid[i][j].heuristicDistance = null;\n        terrain.grid[i][j].direction = null;\n        terrain.grid[i][j].previousNode = null;\n      }\n    }\n    props.stopClearPath();\n  }\n  function animateMaze(nodesToAnimate, type, timerDelay){\n    clearWalls();\n    for(let i = 0; i < nodesToAnimate.length; i++){\n      let nodeRow = nodesToAnimate[i].row;\n      let nodeCol = nodesToAnimate[i].col\n      setTimeout(() => {\n        //const node = nodesToAnimate[i];\n       // node.status = type;\n       terrain.grid[nodeRow][nodeCol].status = \"wall\";\n      tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\n      }, timerDelay * i);\n      props.stopMazeSelection();\n    }\n  }\n  \n  return (\n    <mesh ref = {mesh} position = {[0,0,-10]}>\n      <gridHelper args = {[300, props.gridDimensions, 0x5c78bd, 0x5c78bd] }/>\n      <mesh rotation={[-Math.PI /2, 0, 0]}\n      position={[0,-0.1,0]} \n      receiveShadow = {true}\n      onPointerDown={ (e) => {\n        mouseIsUp = false;\n        mouseDownHandler(e)\n      }}\n      onPointerUp = {e => {\n        if(props.resetStatus === true || mouseIsUp === true){\n          mouseIsUp = true;\n        }\n        mouseUpHandler(e)\n      }}\n      onPointerMove = {e => {\n        if(mouseIsUp === true || props.resetStatus === false){\n          return;\n        }\n        else if(mouseIsUp === false){\n          currentHoverNodeId = Math.floor(e.faceIndex/2);\n          return;\n        }\n      }}\n      >\n      <primitive attach = 'geometry' object = {groundGeometry}  />  \n      <primitive attach = 'material' object = {groundMaterial}  />   \n      </mesh>\n      <axesHelper />\n    </mesh>\n    )\n}\n\n\nexport default Grid\n","export function unweightedSearchAlgorithm(grid, start, target, nodesToAnimate, name) {\n    let structure = [start];\n    let exploredNodes = {start: true};\n    while (structure.length) {\n      let currentNode = name === \"BFS\" ? structure.shift() : structure.pop();\n      nodesToAnimate.push(currentNode);\n      if (name === \"DFS\") exploredNodes[currentNode.id] = true;\n          currentNode.status = \"visited\";\n          // Ending condition\n          if (currentNode.id === target.id) return \"success!\";\n          // Update neighbors\n      let currentNeighbors = getNeighbors(currentNode, grid, name);\n      currentNeighbors.forEach(neighbor => {\n        if (!exploredNodes[neighbor.id]) {\n          if (name === \"BFS\") exploredNodes[neighbor.id] = true;\n                  if(neighbor.id !== start.id) {\n                      neighbor.previousNode = currentNode;\n                  }\n          structure.push(neighbor);\n        }\n          });\n    }\n    return false;\n  }\n  \n  function getNeighbors(node, grid, name) {\n      const neighbors = [];\n      const {col, row} = node;\n      let neighbor;\n      if (row > 0) {\n          neighbor = grid[row - 1][col];\n          if (name === \"BFS\") {\n              neighbors.push(neighbor);\n          } else {\n              neighbors.unshift(neighbor);\n          }\n      }\n      if (row < grid.length - 1) {\n          neighbor = grid[row + 1][col];\n          if (name === \"BFS\") {\n              neighbors.push(neighbor);\n          } else {\n              neighbors.unshift(neighbor);\n          }\n      }\n      if (col > 0) {\n          neighbor = grid[row][col - 1];\n          if (name === \"BFS\") {\n              neighbors.push(neighbor);\n          } else {\n              neighbors.unshift(neighbor);\n          }\n      }\n      if (col < grid[0].length - 1) {\n          neighbor = grid[row][col + 1];\n          if (name === \"BFS\") {\n              neighbors.push(neighbor);\n          } else {\n              neighbors.unshift(neighbor);\n          }\n      }\n      return neighbors.filter(neighbor => neighbor.stutus !== \"visited\");\n  }","import React from 'react'\n\nfunction Floor() {\n    return (\n        <mesh rotation={[-Math.PI /2, 0, 0]} position={[0, -3, -5]}>\n         <planeBufferGeometry attach = 'geometry' args = {[5000, 5000, 30, 30]} />\n        <meshStandardMaterial attach = 'material' color=\"white\"/>    \n        </mesh>\n    )\n}\n\nexport default Floor\n","import { OrbitControls } from 'drei';\nimport React, {useEffect, useRef } from 'react';\nimport { useThree } from 'react-three-fiber';\nimport TWEEN from '@tweenjs/tween.js';\n\n\nfunction Controls(props) {\n    const resetStatus = props.resetStatus;\n    const {\n        camera,\n    } = useThree();\n\n    const controls = useRef();\n\n\n\n    useEffect(() => {\n        if(props.resetStatus === true){\n            resetCamera();\n        }\n       \n    }, [resetStatus]);\n\n    function resetCamera() {\n\n            TWEEN.removeAll();\n\t\t\tnew TWEEN.Tween(camera.position)\n\t\t\t\t.to({ x: 0, y: 380, z: 0 }, 2000)\n\t\t\t\t.easing(TWEEN.Easing.Exponential.Out)\n\t\t\t\t.onComplete(() => {\n                    controls.current.update();\n\t\t\t\t})\n\t\t\t\t.start();\n                \n    } \n\n    return (\n        <OrbitControls ref = {controls} enableRotate = {!props.resetStatus}/>\n    )\n}\n\nexport default Controls\n","import React, { useState, useRef } from 'react';\nimport Grid from './Grid';\nimport { Canvas } from \"react-three-fiber\";\nimport Floor from './Floor';\nimport Controls from './Controls'; \nimport { Button, Select, MenuItem } from '@material-ui/core'\nimport BorderClearIcon from '@material-ui/icons/BorderClear';\nimport TerrainIcon from '@material-ui/icons/Terrain';\nimport UndoIcon from '@material-ui/icons/Undo';\nimport { spacing } from '@material-ui/system';\nimport { makeStyles } from '@material-ui/core/styles';\n//<OrbitControls enabled = {!worldSetup} />\nfunction World(props) {\n   let width = window.innerWidth;\n   let height = window.innerHeigh;\n\n\n   const [selectedAlgorithm,  setSelectedAlgorithm] = useState({});     // keeps track of the algorithm we choose\n   const [runState, setRunState] = useState(false);                     //when runState is true the visualizer algorithm is running\n   const [resetCamera, setResetCamera] = useState(false);               //when resetCamera is true we reset the camera position\n   const [clearWalls, setClearWalls] = useState(false);\n   const [clearPath, setClearPath] = useState(false);\n   const cameraPosition = useRef([0,350,0]);\n   const [selectedMazeAlgorithm, setSelectedMazeAlgorithm] = useState(\"\");\n   const [algorithmSpeed, setAlgorithmSpeed] = useState(\"15\");\n   const [selected_algo_is_undefined, setAlgo] = useState(true)\n   \n   const useStyles = makeStyles((theme) => ({\n    root: {\n      '& > *': {\n        margin: theme.spacing(1),\n        background: 'linear-gradient(45deg, #2196F3 30%, #21CBF3 90%)',\n    border: 0,\n    borderRadius: 3,\n    color: 'white',\n      },\n    },\n  }));\n\n  const classes = useStyles();\n\n\n   //calling on this funciton in the child component (Grid) to update runstate in this parent\n   function updateRunState(newState){\n       setRunState(newState);\n   }\n   function stopClearPath(){\n       setClearPath(false);\n   }\n   function stopClearWalls(){\n       setClearWalls(false);\n   }\n   function handleOnChange(event){\n       if(event.target.value !== undefined){\n           setAlgo(false);\n        }\n       if(event.target.value === undefined){\n        setAlgo(true);\n        }\n       if(event.target.value === \"Dijkstra\"){\n           setSelectedAlgorithm({\n               algorithm: \"Dijkstra\",\n               type: \"weighted\", \n               heuristic: \"\",\n           });\n       }\n       else if(event.target.value === \"aStar\"){\n           setSelectedAlgorithm({\n               algorithm: \"aStar\",\n               type: \"weighted\",\n               heuristic: \"poweredManhattanDistance\",\n           });\n       }\n       else if(event.target.value === \"BFS\"){\n           setSelectedAlgorithm({\n               algorithm: \"BFS\",\n               type: \"unweighted\",\n               heuristic: \"\",\n           });\n       }\n       else if(event.target.value === \"DFS\"){\n           setSelectedAlgorithm({\n               algorithm: \"DFS\",\n               type: \"unweighted\",\n               heuristic: \"\"\n           })\n       }\n   }\n   function updateResetStatus(){\n       setResetCamera(false);\n   }\n   function handleMazeChange(event){\n       setSelectedMazeAlgorithm(event.target.value);\n   }\n   function stopMazeSelection(){\n       setSelectedMazeAlgorithm(\"\");\n   }\n\n    return (\n        <>\n        <div align = \"center\" className={classes.root}>\n        <Select name = \"algorithms\" id = \"algorithms\" displayEmpty onChange={e => handleOnChange(e)}>\n            <MenuItem>Select Algorithm</MenuItem>\n            <MenuItem value = \"Dijkstra\">Dijkstra's Algorithm</MenuItem>\n            <MenuItem value = \"aStar\">A* Search</MenuItem>\n            <MenuItem value = \"BFS\">Breadth First Search</MenuItem>\n            <MenuItem value = \"DFS\">Depth First Search</MenuItem>\n        </Select>\n        <Select name = \"mazes\" id = \"mazes\" displayEmpty onChange = {e => handleMazeChange(e)}>\n            <MenuItem>Select Maze</MenuItem>\n            <MenuItem value = \"randomMaze\">Random Maze</MenuItem>\n            <MenuItem value = \"recursiveDivision\">Recursive Division</MenuItem>\n        </Select>\n        <Button id = \"button1zo\"onClick = {e => setRunState(true)}  \n          variant=\"outlined\"\n          disabled = {runState || selected_algo_is_undefined}\n          startIcon={ <BorderClearIcon />}\n          >Vizualize</Button>\n        <Button onClick = {e => setClearPath(true)}\n          variant=\"outlined\"\n          disabled = {runState}\n          startIcon = {<UndoIcon/>}\n        >Clear Path</Button>\n        <Button onClick = {e => setClearWalls(true)}\n          variant=\"outlined\"\n          disabled = {runState}\n          startIcon = {<UndoIcon/>}\n        >Clear Walls</Button>\n        <Button onClick = {e => setResetCamera(!resetCamera)}\n          variant=\"outlined\"\n          startIcon = {<TerrainIcon />}\n        >Setup World</Button>\n        <Select name = \"algorithmSpeed\" id = \"algorithmSpeed\" displayEmpty onChange = { e=> setAlgorithmSpeed(e.target.value)}>\n            <MenuItem>Select Speed</MenuItem>\n            <MenuItem value = \"15\">Fast</MenuItem>\n            <MenuItem value = \"25\">Medium</MenuItem>\n            <MenuItem value = \"80\">Slow</MenuItem>\n        </Select>\n        </div>\n        <Canvas colorManagement \n        camera={\n            {\n                position: cameraPosition.current,\n                 fov: 52.5,\n                  aspect: width / height, \n                  far: 5000\n                }\n            }\n        >\n        <ambientLight \n            intensity = {1} \n            color = {0xBBC2D0}/>\n        {/*<fog attach = \"fog\" args = {[0xFFFFFF , 0, 750]}/>*/}\n        <hemisphereLight \n            color = {\"hsl(0.6, 1, 0.6)\"} \n            groundColor = {0x87775d} \n            intensity = {0.1} \n            position = {[0,5,0]} \n        />\n        <directionalLight \n            color = {\"hsl(0.1, 1, 0.95)\"} \n            groundColor = {0x87775d} \n            intensity = {0.5} \n            position = {[-70,122.5,70]} \n            castShadow = {true}\n        />   \n        <Grid \n            gridDimensions = {30}\n            updateRunState = {updateRunState}\n            stopClearPath = {stopClearPath}\n            stopClearWalls = {stopClearWalls}\n            stopMazeSelection = {stopMazeSelection}\n            resetStatus = {resetCamera}\n            selectedAlgorithm = {selectedAlgorithm}\n            selectedMazeAlgorithm = {selectedMazeAlgorithm}\n            algorithmSpeed = {algorithmSpeed} \n            worldProperties = {\n            {\n                rows: 30,\n                cols: 30,\n                runState: runState,\n                clearPath: clearPath,\n                clearWalls: clearWalls,\n                start: {\n                    row: 5,\n                    col: 5,\n                },\n                finish: {\n                    row: 25,\n                    col: 25,\n                },\n                colors: {\n                    start: {r: 0, g: 1, b: 0 },\n                    finish: {r: 1, g: 0, b: 0},\n                    wall: {r: 0.109, g: 0.109, b: 0.45},\n                    visited: {r: 0.329, g: 0.27, b: 0.968},\n                    path: {r: 1, g: 1, b: 0},\n                    default: {r: 1, g: 1, b: 1},\n                },\n                nodeDimensions:{\n                    height: 10,\n                    width: 10,\n                },\n            }\n        }/>\n        <Floor/>\n        <Controls \n            resetStatus = {resetCamera}\n            updateResetStatus = {updateResetStatus}\n        />\n      </Canvas>\n      </>\n    )\n}\n\nexport default World\n\n","import React from 'react'\nimport './App.scss';\nimport World from './components/World';\n\n\nfunction App() {\n  return (\n    <>\n      <World/>\n    </>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}